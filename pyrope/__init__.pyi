from collections.abc import Callable, Generator, Mapping, Sequence
from typing import Generic, Never, TypeVar

# Variance-sensitive type parameters require old-style TypeVar
T_co = TypeVar("T_co", covariant=True)
E_co = TypeVar("E_co", covariant=True)
In_contra = TypeVar("In_contra", contravariant=True)
Out_co = TypeVar("Out_co", covariant=True)


class Result(Generic[T_co, E_co]):
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def unwrap(self) -> T_co: ...
    def unwrap_err(self) -> E_co: ...
    def map[U](self, f: Callable[[T_co], U]) -> Result[U, E_co]: ...
    def map_err[U](self, f: Callable[[E_co], U]) -> Result[T_co, U]: ...
    def and_then[U](self, f: Callable[[T_co], Result[U, E_co]]) -> Result[U, E_co]: ...


class Option(Generic[T_co]):
    def is_some(self) -> bool: ...
    def is_none(self) -> bool: ...
    def unwrap(self) -> T_co: ...
    def map[U](self, f: Callable[[T_co], U]) -> Option[U]: ...
    def unwrap_or[U](self, default: U) -> T_co | U: ...


class ErrorKind:
    InvalidInput: ErrorKind
    NotFound: ErrorKind
    Internal: ErrorKind


class RopeError:
    @property
    def kind(self) -> ErrorKind: ...
    @property
    def code(self) -> str: ...
    @property
    def message(self) -> str: ...
    @property
    def metadata(self) -> dict[str, str]: ...
    @property
    def op(self) -> str | None: ...
    @property
    def path(self) -> list[str | int]: ...
    @property
    def expected(self) -> str | None: ...
    @property
    def got(self) -> str | None: ...
    @property
    def cause(self) -> str | None: ...


class Operator(Generic[In_contra, Out_co]): ...


class Blueprint[OrigIn, Out]:
    def __new__(cls) -> Blueprint[object, object]: ...
    @classmethod
    def for_type[T_in](cls, t: type[T_in]) -> Blueprint[T_in, T_in]: ...
    @classmethod
    def any(cls) -> Blueprint[object, object]: ...
    def pipe[NextOut](self, operator: Operator[Out, NextOut]) -> Blueprint[OrigIn, NextOut]: ...
    def guard_str(self: Blueprint[OrigIn, object]) -> Blueprint[OrigIn, str]: ...


class Op:
    @staticmethod
    def assert_str() -> Operator[object, str]: ...
    @staticmethod
    def split(delim: str) -> Operator[str, Sequence[str]]: ...
    @staticmethod
    def index[T](idx: int) -> Operator[Sequence[T], T]: ...
    @staticmethod
    def get[T](key: str) -> Operator[Mapping[str, T], T]: ...
    @staticmethod
    def to_uppercase() -> Operator[str, str]: ...


def Ok[T](value: T) -> Result[T, Never]: ...
def Err[E](error: E) -> Result[Never, E]: ...


def Some[T](value: T) -> Option[T]: ...
def None_() -> Option[Never]: ...


type Do[T, E, R] = Generator[Result[T, E], T, Result[R, E]]


def do[**P, T, E, R](fn: Callable[P, Do[T, E, R]]) -> Callable[P, Result[R, E]]: ...


def run[OrigIn, Out](blueprint: Blueprint[OrigIn, Out], input: OrigIn) -> Result[Out, RopeError]: ...


__all__: list[str]
