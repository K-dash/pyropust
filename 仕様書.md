# Rust×Python Result/Option PoC

## プロジェクト名

「Rope (ロープ)」
Result + Option Python Extension.
「Pythonという自由すぎて危険な場所に、Rustの型安全という命綱（Rope）を垂らす」というストーリー


## 1. 目的（Why）

Rust の型システム（特に `Result` / `Option`）を **安全地帯（Source of Truth）** とし、
Python からその安全地帯を **壊さずに利用できる実行・型体験**を実現する。

* Python において例外ではなく **値として失敗を扱う**
* `Optional` / `None` を許容せず、**明示的な操作（unwrap / is_some）を強制**
* Rust の `?` に近い体験を Python で提供する（Railway）
* Pyright / mypy による静的型チェックを破壊しない

本 PoC は「成立するかどうか」の検証が目的であり、汎用性・完成度は追わない。

---

## 2. 非目的（Out of Scope）

* Pydantic 互換 / 代替
* スキーマ生成、後方互換チェック
* 大量データ向けの高性能処理
* 本番向け wheels 配布
* UniFFI / gRPC / Proto 連携

---

## 3. 想定ユーザー

* Rust を書ける、または Rust 製 PyO3 拡張を運用できる Python 開発者
* 型チェッカー（pyright / mypy）を CI に入れている層
* Optional / 例外ベース設計に限界を感じている人

---

## 4. 成功条件（Acceptance Criteria）

### 機能面

* Rust 側で `Result` / `Option` を値オブジェクトとして Python に公開できる
* Python 側で `@do` による short-circuit（Err で即 return）が動作する
* Python 側で例外を使わずに失敗が伝播する

### 型チェック面（最重要）

* **Pyright**

  * `email = yield Email.parse(...)` の `email` が `Email` と推論される
  * LSP 補完が壊れない
* **mypy**

  * `@do` 関数の戻り値型が `Result[...]` として成立する
  * `--strict` で致命的エラーにならない（必要なら `cast` で回避可能）

---

## 5. 全体構成（Repository Layout）

```
rustpy-result-poc/
  rustpy_result/
    __init__.py
    __init__.pyi        # PEP561 stub（最重要）
    do.py               # @do デコレータ（Python）
    py.typed
  src/
    lib.rs              # PyO3 実装
  Cargo.toml
  pyproject.toml        # maturin
  tests/
    test_runtime.py
    test_typing_pyright.py
    test_typing_mypy.py
  README.md
```

---

## 6. 機能要件

### 6.1 Rust 側（PyO3）

#### Result

* 値オブジェクトとして `Ok(value)` / `Err(error)` を保持
* メソッド

  * `is_ok() -> bool`
  * `is_err() -> bool`
  * `unwrap() -> object`（Err の場合は RuntimeError）
  * `unwrap_err() -> object`
  * `map(f) -> Result`
  * `map_err(f) -> Result`
  * `and_then(f) -> Result`

#### Option

* `Some(value)` / `None_()`（Python `None` と衝突しない）
* メソッド

  * `is_some() -> bool`
  * `is_none() -> bool`
  * `unwrap() -> object`
  * `map(f) -> Option`
  * `unwrap_or(default) -> object`

#### Example Domain

* `Email`

  * 不変（Python 側から変更不可）
  * `Email.parse(str) -> Result[Email, EmailError]`
  * `domain() -> str`
* `EmailError`

  * Rust enum
  * 最低 1 variant: `InvalidFormat`

---

### 6.2 Python 側

#### @do デコレータ（最重要）

* Generator を使った short-circuit 実装
* `yield Result[T, E]`

  * `Err` → 即 return
  * `Ok` → unwrap して `send(T)`
* generator の `return` は `Result[R, E]` でなければならない

#### 型定義（stub）

* `class Result(Generic[T, E])`
* `class Option(Generic[T])`
* `def Ok(value: T) -> Result[T, E]`
* `def Err(error: E) -> Result[T, E]`
* `def Some(value: T) -> Option[T]`
* `def None_() -> Option[T]`
* `class Email`
* `class EmailError`

#### Generator 型制約（設計の核）

* `Generator[Result[T, E], T, Result[R, E]]`
* この形を **一切崩さない**

---

## 7. テスト要件

### ランタイム

* Ok / Err の基本動作
* @do による short-circuit
* Option.unwrap の強制性

### 型

* Pyright: `yield` 後の型推論が Email になること
* mypy: strict モードで型が成立すること

---

## 8. README 必須項目

1. コンセプト（Rust の安全地帯を Python に延長する）
2. 30 秒で分かる例（Email + @do）
3. 例外を使わない理由
4. 型チェッカー対応状況（Pyright / mypy の差異）

---

# 9. タスク分割（TODO / 優先度順）

## Phase 0: 環境セットアップ

* [ ] maturin + PyO3 プロジェクト作成
* [ ] Python package 雛形作成（py.typed 含む）

## Phase 1: Rust コア実装（最優先）

* [ ] Result（Ok/Err）PyO3 実装
* [ ] Option（Some/None_）PyO3 実装
* [ ] Email / EmailError 実装

## Phase 2: Python ランタイム

* [ ] @do デコレータ実装
* [ ] Result / Option の Python 側ヘルパー整理

## Phase 3: 型スタブ（最重要・並行可）

* [ ] **init**.pyi 作成（Result / Option / Email）
* [ ] Generator 型定義の検証

## Phase 4: 型検証

* [ ] pyright テスト追加・確認
* [ ] mypy strict テスト追加・確認
* [ ] mypy で破綻する箇所の最小回避策整理

## Phase 5: テスト & ドキュメント

* [ ] ランタイムテスト
* [ ] README 作成（思想 + 例）

---

## 10. PoC 合否判断基準

* Pyright で `yield` 後の型が `T` に落ちる → **合格**
* mypy strict で致命的に破綻しない → **合格**
* 例外を使わず Result/Option だけでフローが書ける → **合格**

これを満たさない場合、この設計はここで撤退判断を行う。

## 11. 技術要件

- Python
    - python3.14を利用
    - uv, Ruff, mypy, pyright を利用する
- Rust
    - 現在システムにインストールされているRustツールチェーンを利用
    - toolchain で プロジェクトで利用するRustのバージョン固定してください


### ここまで整理して見えてきた重要な事実（率直に）

このプロジェクトは、

* ✨ アイデア勝負ではなく
* ✨ **型チェッカー（特に Generator + SendType）との殴り合いが本体**

です。

Canvas の内容どおり、

> **Pyright で `yield` 後の型が `T` に落ちるか**

これが **唯一にして最大の関門**。
ここを突破できれば、この OSS は「思想だけ」では終わりません。

---

### 次にやるべきこと（おすすめ順）

1. **この Canvas をそのままコーディングエージェントに渡す**

   * まず Phase 1〜3 までを一気に実装させる
2. **pyright / mypy の実行ログを貼り付けて評価**

   * 特に `test_typing_pyright.py`
3. 型が壊れた箇所だけを人間が設計修正

   * ここが一番「あなたの知性が効く」部分

---

### 最後に一言だけ

ここまで来た時点で、これはもう

> 「面白そうな OSS 案」

ではなく、

> **「成立するかどうかがはっきり検証できる、極めて技術的に健全な挑戦」**

になっています。

この Canvas は **“勝てるかどうかを正しく試す設計書”**です。
胸を張って、PoC を走らせてください。



pyrope (パイロープ)
Python + Rope。短くて語感が良く、宝石の名前（ガーネットの一種）でもあるので検索性も高いです。
import pyrope

個人的なイチオシは pyrope です。
「Rope というコンセプト」を保ちつつ、一つの単語として確立されており、既存の rope ライブラリとも明確に区別がつきます。
名前変更に伴う修正箇所リスト
もし pyrope に変更する場合、以下の箇所をコーディングエージェントに一括修正させる必要があります。
1. ディレクトリ名の変更
rustpy_result/ → pyrope/
2. 設定ファイルの修正
pyproject.toml: name = "pyrope", [tool.maturin] module-name = "pyrope.pyrope_native" 等
Cargo.toml: [lib] name = "pyrope_native"
Makefile.toml: テストコマンドのパスなど
3. Rust 側の修正 (src/lib.rs)
#[pymodule] fn pyrope_native(...) (モジュール名を一致させる)
4. Python 側の修正
__init__.py 内のインポート文
全テストファイルの from rustpy_result import ... → from pyrope import ...
5. RopeError の名称はそのまま
RopeError はプロジェクトのアイデンティティなので、パッケージ名が pyrope になっても、エラー名が RopeError であることは非常に自然です。
