# Auto-generated by tools/gen_native_stub.py
# Do not edit manually! Edit pyropust/__init__.pyi instead.
#
# This file provides type information for the native Rust module.
# For the public API, see pyropust/__init__.pyi.

from collections.abc import Callable, Mapping
from enum import StrEnum
from typing import Generic, Never, TypeVar

class ErrorCode(StrEnum): ...  # type: ignore[misc]

# Variance-sensitive type parameters require old-style TypeVar
T_co = TypeVar("T_co", covariant=True)
E_co = TypeVar("E_co", covariant=True)

class Result(Generic[T_co, E_co]):
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def is_ok_and(self, predicate: Callable[[T_co], object]) -> bool: ...
    def is_err_and(self, predicate: Callable[[E_co], object]) -> bool: ...
    def unwrap(self) -> T_co: ...
    def unwrap_err(self) -> E_co: ...
    def expect(self, msg: str) -> T_co: ...
    def expect_err(self, msg: str) -> E_co: ...
    def unwrap_or[U](self, default: U) -> T_co | U: ...
    def unwrap_or_else[U](self, f: Callable[[E_co], U]) -> T_co | U: ...
    def ok(self) -> Option[T_co]: ...
    def err(self) -> Option[E_co]: ...
    def map[U](self, f: Callable[[T_co], U]) -> Result[U, E_co]: ...
    def map_try[U, CodeT: ErrorCode](
        self: Result[T_co, Error[CodeT]],
        f: Callable[[T_co], U],
        *,
        code: CodeT,
        message: str,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[U, Error[CodeT]]: ...
    def and_then_try[U, CodeT: ErrorCode](
        self: Result[T_co, Error[CodeT]],
        f: Callable[[T_co], Result[U, Error[CodeT]]],
        *,
        code: CodeT,
        message: str,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[U, Error[CodeT]]: ...
    def map_err[U](self, f: Callable[[E_co], U]) -> Result[T_co, U]: ...
    def map_or[U](self, default: U, f: Callable[[T_co], U]) -> U: ...
    def map_or_else[U](self, default_f: Callable[[E_co], U], f: Callable[[T_co], U]) -> U: ...
    def inspect(self, f: Callable[[T_co], object]) -> Result[T_co, E_co]: ...
    def inspect_err(self, f: Callable[[E_co], object]) -> Result[T_co, E_co]: ...
    def context[CodeT: ErrorCode](
        self: Result[T_co, Error[CodeT]],
        message: str,
        *,
        code: CodeT | str = "context",
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[T_co, Error[CodeT]]: ...
    def with_code[CodeT: ErrorCode](
        self: Result[T_co, Error[CodeT]], code: CodeT | str
    ) -> Result[T_co, Error[CodeT]]: ...
    def map_err_code[CodeT: ErrorCode](
        self: Result[T_co, Error[CodeT]], prefix: str
    ) -> Result[T_co, Error[CodeT]]: ...
    def and_[U](self, other: Result[U, E_co]) -> Result[U, E_co]: ...
    def or_(self, other: Result[T_co, E_co]) -> Result[T_co, E_co]: ...
    def or_else(self, f: Callable[[E_co], Result[T_co, E_co]]) -> Result[T_co, E_co]: ...
    def and_then[U](self, f: Callable[[T_co], Result[U, E_co]]) -> Result[U, E_co]: ...
    def flatten[T, E](self: Result[Result[T, E], E]) -> Result[T, E]: ...
    def transpose[T, E](self: Result[Option[T], E]) -> Option[Result[T, E]]: ...
    def unwrap_or_raise(self, exc: BaseException) -> T_co: ...
    @classmethod
    def attempt[T](
        cls, f: Callable[[], T], *exceptions: type[BaseException]
    ) -> Result[T, Error[ErrorCode]]: ...

class Option(Generic[T_co]):
    def is_some(self) -> bool: ...
    def is_none(self) -> bool: ...
    def is_some_and(self, predicate: Callable[[T_co], object]) -> bool: ...
    def is_none_or(self, predicate: Callable[[T_co], object]) -> bool: ...
    def unwrap(self) -> T_co: ...
    def expect(self, msg: str) -> T_co: ...
    def unwrap_or[U](self, default: U) -> T_co | U: ...
    def unwrap_or_else[U](self, f: Callable[[], U]) -> T_co | U: ...
    def map[U](self, f: Callable[[T_co], U]) -> Option[U]: ...
    def map_try[U, CodeT: ErrorCode](
        self,
        f: Callable[[T_co], U],
        *,
        code: CodeT,
        message: str,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[Option[U], Error[CodeT]]: ...
    def map_or[U](self, default: U, f: Callable[[T_co], U]) -> U: ...
    def map_or_else[U](self, default_f: Callable[[], U], f: Callable[[T_co], U]) -> U: ...
    def inspect(self, f: Callable[[T_co], object]) -> Option[T_co]: ...
    def filter(self, predicate: Callable[[T_co], object]) -> Option[T_co]: ...
    def and_[U](self, other: Option[U]) -> Option[U]: ...
    def and_then[U](self, f: Callable[[T_co], Option[U]]) -> Option[U]: ...
    def and_then_try[U, CodeT: ErrorCode](
        self,
        f: Callable[[T_co], Option[U]],
        *,
        code: CodeT,
        message: str,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[Option[U], Error[CodeT]]: ...
    def or_(self, other: Option[T_co]) -> Option[T_co]: ...
    def or_else(self, f: Callable[[], Option[T_co]]) -> Option[T_co]: ...
    def xor(self, other: Option[T_co]) -> Option[T_co]: ...
    def flatten[T](self: Option[Option[T]]) -> Option[T]: ...
    def transpose[T, E](self: Option[Result[T, E]]) -> Result[Option[T], E]: ...
    def zip[U](self, other: Option[U]) -> Option[tuple[T_co, U]]: ...
    def zip_with[U, R](self, other: Option[U], f: Callable[[T_co, U], R]) -> Option[R]: ...
    def ok_or[CodeT: ErrorCode](
        self,
        code: CodeT,
        message: str,
        *,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        cause: str | None = None,
    ) -> Result[T_co, Error[CodeT]]: ...
    def ok_or_else[CodeT: ErrorCode](
        self,
        code: CodeT,
        f: Callable[[], str | Error[CodeT]],
        *,
        kind: ErrorKind | str | None = None,
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        cause: str | None = None,
    ) -> Result[T_co, Error[CodeT]]: ...

class ErrorKind:
    InvalidInput: ErrorKind
    NotFound: ErrorKind
    Internal: ErrorKind

class Error[CodeT: ErrorCode]:
    @property
    def kind(self) -> ErrorKind: ...
    @property
    def code(self) -> CodeT: ...
    @property
    def message(self) -> str: ...
    @property
    def metadata(self) -> dict[str, str]: ...
    @property
    def op(self) -> str | None: ...
    @property
    def path(self) -> list[str | int]: ...
    @property
    def expected(self) -> str | None: ...
    @property
    def got(self) -> str | None: ...
    @property
    def cause(self) -> str | None: ...
    def to_dict(self) -> dict[str, object]: ...
    @classmethod
    def from_dict(cls, data: dict[str, object]) -> Error[ErrorCode]: ...
    @classmethod
    def new(
        cls,
        code: CodeT,
        message: str,
        *,
        kind: ErrorKind | str | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        metadata: Mapping[str, str] | None = None,
    ) -> Error[CodeT]: ...
    @classmethod
    def wrap(
        cls,
        err: BaseException | Error[CodeT],
        *,
        code: CodeT,
        message: str,
        kind: ErrorKind | str | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        metadata: Mapping[str, str] | None = None,
    ) -> Error[CodeT]: ...

def Ok[T](value: T) -> Result[T, Error[ErrorCode]]: ...
def Err[CodeT: ErrorCode](error: Error[CodeT]) -> Result[Never, Error[CodeT]]: ...
def err[CodeT: ErrorCode](
    code: CodeT,
    message: str,
    *,
    kind: ErrorKind | str | None = None,
    metadata: Mapping[str, str] | None = None,
    op: str | None = None,
    path: list[str | int] | None = None,
    expected: str | None = None,
    got: str | None = None,
    cause: str | None = None,
) -> Result[Never, Error[CodeT]]: ...
def bail[CodeT: ErrorCode](
    code: CodeT,
    message: str,
    *,
    kind: ErrorKind | str | None = None,
    metadata: Mapping[str, str] | None = None,
    op: str | None = None,
    path: list[str | int] | None = None,
    expected: str | None = None,
    got: str | None = None,
    cause: str | None = None,
) -> Result[Never, Error[CodeT]]: ...
def ensure[CodeT: ErrorCode](
    condition: object,
    code: CodeT,
    message: str,
    *,
    kind: ErrorKind | str | None = None,
    metadata: Mapping[str, str] | None = None,
    op: str | None = None,
    path: list[str | int] | None = None,
    expected: str | None = None,
    got: str | None = None,
    cause: str | None = None,
) -> Result[None, Error[CodeT]]: ...
def Some[T](value: T) -> Option[T]: ...
def None_() -> Option[Never]: ...
def exception_to_error(exc: BaseException, code: str = "py_exception") -> Error[ErrorCode]: ...
